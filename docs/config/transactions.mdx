
# Sistema de Transa√ß√µes

O HelperDB oferece um sistema robusto de transa√ß√µes que garante consist√™ncia dos dados atrav√©s de opera√ß√µes at√¥micas com suporte a rollback.

## Configura√ß√£o

```javascript
const { HelperDB } = require('helper.db');

const db = new HelperDB({
    driver: 'sqlite',
    filePath: './data.sqlite',
    transactions: {
        enabled: true,
        isolation: 'READ_COMMITTED',
        timeout: 30000, // 30 segundos
        maxRetries: 3
    }
});
```

## Transa√ß√µes B√°sicas

### Transa√ß√£o Simples
```javascript
// Iniciar transa√ß√£o
const transaction = await db.transaction();

try {
    await transaction.set('user:1', { name: 'Jo√£o', balance: 1000 });
    await transaction.set('user:2', { name: 'Maria', balance: 500 });
    
    // Confirmar altera√ß√µes
    await transaction.commit();
    console.log('‚úÖ Transa√ß√£o conclu√≠da');
} catch (error) {
    // Reverter altera√ß√µes
    await transaction.rollback();
    console.error('‚ùå Transa√ß√£o revertida:', error);
}
```

### Transa√ß√£o com Callback
```javascript
await db.transaction(async (tx) => {
    await tx.set('user:1', { name: 'Jo√£o', balance: 1000 });
    await tx.set('user:2', { name: 'Maria', balance: 500 });
    
    // Se qualquer erro ocorrer, rollback autom√°tico
    const user1 = await tx.get('user:1');
    if (user1.balance < 0) {
        throw new Error('Saldo n√£o pode ser negativo');
    }
    
    // Commit autom√°tico se n√£o houver erros
});
```

## N√≠veis de Isolamento

### READ_UNCOMMITTED
```javascript
const db = new HelperDB({
    transactions: {
        isolation: 'READ_UNCOMMITTED' // Menor isolamento, maior performance
    }
});
```

### READ_COMMITTED
```javascript
const db = new HelperDB({
    transactions: {
        isolation: 'READ_COMMITTED' // Padr√£o - bom equil√≠brio
    }
});
```

### REPEATABLE_READ
```javascript
const db = new HelperDB({
    transactions: {
        isolation: 'REPEATABLE_READ' // Maior consist√™ncia
    }
});
```

### SERIALIZABLE
```javascript
const db = new HelperDB({
    transactions: {
        isolation: 'SERIALIZABLE' // M√°ximo isolamento
    }
});
```

## Opera√ß√µes Transacionais

### Transfer√™ncia de Dinheiro
```javascript
async function transferMoney(fromUserId, toUserId, amount) {
    return await db.transaction(async (tx) => {
        // Obter saldos atuais
        const fromUser = await tx.get(`user:${fromUserId}`);
        const toUser = await tx.get(`user:${toUserId}`);
        
        // Valida√ß√µes
        if (!fromUser || !toUser) {
            throw new Error('Usu√°rio n√£o encontrado');
        }
        
        if (fromUser.balance < amount) {
            throw new Error('Saldo insuficiente');
        }
        
        // Atualizar saldos
        fromUser.balance -= amount;
        toUser.balance += amount;
        
        await tx.set(`user:${fromUserId}`, fromUser);
        await tx.set(`user:${toUserId}`, toUser);
        
        // Registrar transa√ß√£o
        await tx.set(`transaction:${Date.now()}`, {
            from: fromUserId,
            to: toUserId,
            amount,
            timestamp: new Date().toISOString()
        });
        
        return { success: true, newBalance: fromUser.balance };
    });
}

// Uso
try {
    const result = await transferMoney(1, 2, 100);
    console.log('Transfer√™ncia realizada:', result);
} catch (error) {
    console.error('Falha na transfer√™ncia:', error.message);
}
```

## Transa√ß√µes Aninhadas (Savepoints)

```javascript
await db.transaction(async (tx) => {
    await tx.set('user:1', { name: 'Jo√£o' });
    
    // Criar savepoint
    const savepoint = await tx.savepoint('user_creation');
    
    try {
        // Opera√ß√µes que podem falhar
        await tx.set('user:2', { name: 'Maria', invalidField: null });
        await tx.set('profile:2', { userId: 2, avatar: 'large_file.jpg' });
        
        // Commit do savepoint
        await savepoint.release();
    } catch (error) {
        // Rollback apenas para o savepoint
        await savepoint.rollback();
        console.log('Rollback parcial realizado');
    }
    
    // user:1 ainda ser√° commitado
});
```

## Controle de Concorr√™ncia

### Lock de Registros
```javascript
await db.transaction(async (tx) => {
    // Lock exclusivo
    const user = await tx.get('user:1', { lock: 'exclusive' });
    
    // Opera√ß√µes cr√≠ticas
    user.balance += 100;
    await tx.set('user:1', user);
    
    // Lock ser√° liberado automaticamente no commit
});
```

### Lock de Leitura
```javascript
await db.transaction(async (tx) => {
    // Lock compartilhado (m√∫ltiplas leituras, sem escrita)
    const users = await tx.search('user:*', { lock: 'shared' });
    
    // Processar dados sem modific√°-los
    const totalBalance = users.reduce((sum, [_, user]) => sum + user.balance, 0);
    
    await tx.set('stats:total_balance', totalBalance);
});
```

## Configura√ß√£o Avan√ßada

```javascript
const db = new HelperDB({
    driver: 'postgres',
    transactions: {
        enabled: true,
        isolation: 'READ_COMMITTED',
        timeout: 30000,
        maxRetries: 3,
        
        // Configura√ß√µes de performance
        maxConnections: 10,
        connectionTimeout: 5000,
        
        // Deadlock detection
        deadlockDetection: true,
        deadlockTimeout: 10000,
        
        // Callbacks
        onBegin: (txId) => {
            console.log(`üîÑ Transa√ß√£o iniciada: ${txId}`);
        },
        
        onCommit: (txId, duration) => {
            console.log(`‚úÖ Transa√ß√£o commitada: ${txId} (${duration}ms)`);
        },
        
        onRollback: (txId, reason) => {
            console.log(`‚ùå Transa√ß√£o revertida: ${txId} - ${reason}`);
        },
        
        onDeadlock: (txId, conflictingTxId) => {
            console.warn(`‚ö†Ô∏è Deadlock detectado: ${txId} vs ${conflictingTxId}`);
        }
    }
});
```

## Monitoramento de Transa√ß√µes

### Estat√≠sticas
```javascript
const stats = await db.transactions.getStats();
console.log(stats);
// {
//   active: 2,
//   committed: 1250,
//   rolledBack: 15,
//   deadlocks: 2,
//   avgDuration: 150, // ms
//   successRate: 0.988
// }
```

### Transa√ß√µes Ativas
```javascript
const active = await db.transactions.getActive();
console.log(active);
// [
//   {
//     id: 'tx_001',
//     startTime: '2023-12-15T14:30:00Z',
//     duration: 5000,
//     operations: 3,
//     isolation: 'READ_COMMITTED'
//   }
// ]
```

### Eventos
```javascript
db.on('transaction:begin', (txInfo) => {
    console.log('Transa√ß√£o iniciada:', txInfo.id);
});

db.on('transaction:commit', (txInfo) => {
    console.log(`Transa√ß√£o commitada: ${txInfo.id} (${txInfo.duration}ms)`);
});

db.on('transaction:rollback', (txInfo) => {
    console.log(`Transa√ß√£o revertida: ${txInfo.id} - ${txInfo.reason}`);
});

db.on('transaction:timeout', (txInfo) => {
    console.warn(`Transa√ß√£o expirou: ${txInfo.id}`);
});
```

## Exemplo Completo - Sistema de Pedidos

```javascript
class OrderService {
    constructor(db) {
        this.db = db;
    }
    
    async createOrder(userId, items) {
        return await this.db.transaction(async (tx) => {
            // Verificar usu√°rio
            const user = await tx.get(`user:${userId}`);
            if (!user) {
                throw new Error('Usu√°rio n√£o encontrado');
            }
            
            // Calcular total e verificar estoque
            let total = 0;
            const reservedItems = [];
            
            for (const item of items) {
                const product = await tx.get(`product:${item.productId}`, { 
                    lock: 'exclusive' 
                });
                
                if (!product) {
                    throw new Error(`Produto ${item.productId} n√£o encontrado`);
                }
                
                if (product.stock < item.quantity) {
                    throw new Error(`Estoque insuficiente para ${product.name}`);
                }
                
                // Reservar estoque
                product.stock -= item.quantity;
                await tx.set(`product:${item.productId}`, product);
                
                total += product.price * item.quantity;
                reservedItems.push({
                    productId: item.productId,
                    name: product.name,
                    price: product.price,
                    quantity: item.quantity
                });
            }
            
            // Verificar saldo
            if (user.balance < total) {
                throw new Error('Saldo insuficiente');
            }
            
            // Criar pedido
            const orderId = `order:${Date.now()}`;
            const order = {
                id: orderId,
                userId,
                items: reservedItems,
                total,
                status: 'pending',
                createdAt: new Date().toISOString()
            };
            
            await tx.set(orderId, order);
            
            // Debitar do usu√°rio
            user.balance -= total;
            await tx.set(`user:${userId}`, user);
            
            // Atualizar estat√≠sticas
            await tx.add('stats:total_orders', 1);
            await tx.add('stats:revenue', total);
            
            return order;
        });
    }
}

// Uso
const orderService = new OrderService(db);

try {
    const order = await orderService.createOrder(1, [
        { productId: 'prod:1', quantity: 2 },
        { productId: 'prod:2', quantity: 1 }
    ]);
    
    console.log('‚úÖ Pedido criado:', order.id);
} catch (error) {
    console.error('‚ùå Falha ao criar pedido:', error.message);
}
```
